\section{Shortest Path of DAGs and Shortest Path Tree}

\subsection*{Shortest Path of DAGs}
Let $G = (V, E)$ be a DAG with possibly negative edge length $c(e)$ for each $e\in E$.
We want to find the distance from a given source $s$ to each vertex $v\in V$.
Note that $G$ does not contain negative cycles simply because $G$ does not contain any cycle.
We can design a simpler version of Bellman-Ford algorithm to solve this problem.
In particular, we only need to do one round of ``update''~(instead of $|V|-1$ rounds as in Bellman-Ford algorithm).
But, the edges cannot be updated in a arbitrary order. In fact,
we first need to find a linearization of $G$~(recall that a directed graph can be linearized if and only if it's a DAG),
and then update the in-edges of vertices following this linearization.

%%\begin{minipage}{0.8\textwidth}
%%	\aaA {5}{procedure update~(edge $(u,v)\in E$)}\xxx
%%	\aaB {3}{if~($dist[v] > dist[u] + l(u,v)$)}\xxx
%%	\aac {$dist[v] = dist[u] + l(u,v)$;}\xxx
%%	\aac {\textcolor{black}{$prev[v]= u$};}\xxx
%%	\aab {end if;}\xxx
%%	\aaa {end procedure;}\xxx
%%\end{minipage}

\begin{minipage}{0.8\textwidth}
	\aaA {10}{Algorithm DP-shortest-path~(DAG $G = (V, E)$, $l(e)$ for any $e\in E$, $s \in V$)}\xxx
	\aab {init array $dist$ of size $|V|$: $dist[s] = 0$; $dist[v] = \infty$ for any $v\neq s$;}\xxx
	\aab {calculate a linearization of $G$;}\xxx
	\aaB {4}{\textcolor{blue}{for $v\in V$ following the order of linearization}}\xxx
	\aaC {2}{for each $(u,v)\in E$;}\xxx
	\aad {$update(u,v)$;}\xxx
	\aac {end for;}\xxx
	\aab {end for;}\xxx
	\aab {for each $v\in V$: report: $distance(s,v) = dist[v]$;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}


The correctness of above algorithm for DAGs can also be proved in the same way as in the Bellman-Ford algorithm.
Let $p = s \to a \to b \to \cdots \to u \to v$ be the shortest path from $s$ to $v$;
we have proved that~(for Bellman-Ford algorithm), if the run of the algorithm contains a \emph{subsequence} of update procedures
that sequentially update the edges in the shortest path, then 
$dist[v]$ will be equal to $distance(s,v)$ after these update procedures.
Our above algorithm update the in-edges of vertices sequentially following a linearization.
In a DAG, the list of vertices of any path, including shortest path, must be a \emph{subsequence}
of the linearization. Therefore, the list of edges of any path must be updated
sequentially by the algorithm. See Figure~\ref{fig:dag}.

\begin{figure}[h]
\centering{\input{dag}}
\caption{Illustration of the correctness of the DP algorithm for DAGs.}
\label{fig:dag}
\end{figure}


\subsection*{Shortest Path Tree}

So far we have designed three algorithms, BFS, Dijkstra's algorithm, and Bellman-Ford algorithm
to solve shortest path problems for unit edge length, positive edge length, and possible negative edge length, respectively.
In these algorithm, $dist[v]$ will give the \emph{length} of the
shortest path from $s$ to $v$. How to find the actual shortest path?
Before designing algorithm to find paths~(we will do it by modifying all three algorithm),
let's think about how to store them first.
Recall that we want to store $|V|$ paths, ones from $s$ to each vertex in $V$.
If we implicitly store these $|V|$ paths in a naive way, it may take $O(|V|^2)$ space.
Can we do better?

In fact, we can use linear space to store these $|V|$ shortest paths from a single source $s$.
Let $G = (V, E)$ be a graph with edge length $l(e)$ for any $e \in E$.
Here we allow negative edge length, but not allow \emph{negative cycle}. %~(we will come back to negative cycle later on).
Let $s \in V$ be a source vertex.  Without loss of generality, assume that $s$ can reach all vertices in $V$.
We say $T$ is a \emph{shortest path tree} of $G$ w.r.t.\ source vertex $s$ if:
\vspace*{-\topsep}
\begin{enumerate}
\item $T$ is a rooted tree and its root is $s$;
\item vertices of $T$ is $V$;
\item edges of $T$ is a subset of $E$;
\item for every $v\in V$, the unique path from $s$ to $v$ in $T$ is one shortest path from $s$ to $v$ in $G$.
\end{enumerate}

A shortest path tree always exists. (Think how to prove it.) 
The underlying reason is the optimal substructure property.
Such tree may not be unique though~(see Figure~\ref{fig:tree}).
As in the shortest path tree, each vertex, except $s$, has exactly one in-edge, we can use an array $prev$ of size $|V|$
to store this tree. Array $prev$ is indexed by the vertices, and for each $v\in V$, $prev[v]$ stores the parent of $v$
in the tree~(see Figure~\ref{fig:tree}).
Such array, which takes linear space, therefore represents the shortest path from $s$ to every vertex.

\begin{figure}[h]
\centering{\input{tree}}
\caption{A directed graph and its two shortest path trees. The array representation
for the first tree is $prev[s,a,b,c,f,h,j,k] = [null, s, a, f, s, c, c, b]$.}
\label{fig:tree}
\end{figure}


\subsection*{Determining Shortest Path Tree}

We now modify the three algorithms, namely BFS, Dijkstra's algorithm, and Bellman-Ford algorithm, to allow them to generate a shortest path tree.
The idea is to keep track of its predecessor of each vertex~(essentially the parent of $v$ in the shortest path tree).
We use array $prev$ of size $|V|$ to do it.
Whenever $dist[v]$ gets updated as $dist[u] + l(u,v)$ we also update $prev[v]$ as $u$.
See their pseudo-codes below.
for Bellman-Ford algorithm 

\begin{minipage}{0.8\textwidth}
	\aaA {17}{Algorithm BFS~($G = (V, E), s \in V$)}\xxx
	\aab {$dist[v] = \infty$, for any $v\in V$;}\xxx
	\aab {\textcolor{blue}{$prev[v] = null$, for any $v\in V$};}\xxx
	\aab {init an empty queue $Q$;}\xxx
	\aab {$dist[s] = 0$;}\xxx
	\aab {insert~($Q, s$);}\xxx
	\aaB {9}{while~(empty~($Q$) = false)}\xxx
	\aac {$u$ = find-earliest~($Q$);}\xxx
	\aac {delete-earliest~($Q$);}\xxx
	\aaC {5}{for each edge~$(u, v)\in E$}\xxx
	\aaD {4}{if~($dist[v] = \infty$)}\xxx
	\aae {$dist[v] = dist[u] + 1$;}\xxx
	\aae {\textcolor{blue}{$prev[v] = u$;}}\xxx
	\aae {insert~($Q$, $v$);}\xxx
	\aad {end if;}\xxx
	\aac {end for;}\xxx
	\aab {end while;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}



\begin{minipage}{0.8\textwidth}
	\aaA {18}{Algorithm Dijkstra~($G = (V, E)$, $l(e)$ for any $e\in E$, $s \in V$)}\xxx
	\aab {$dist[v] = \infty$, for any $v\in V$;}\xxx
	\aab {\textcolor{blue}{$prev[v] = null$, for any $v\in V$};}\xxx
	\aab {init an empty priority queue $PQ$;}\xxx
	\aab {for any $v\in V$: insert~($PQ$, $v$), where the priority of $v$ is $\infty$;}\xxx
	\aab {$dist[s] = 0$;}\xxx
	\aab {decrease-key~($PQ, s, 0$);}\xxx
	\aaB {10}{while~(empty~($PQ$) = false)}\xxx
	\aac {$u$ = find-min~($PQ$);}\xxx
	\aac {delete-min~($PQ$);}\xxx
	\aaC {6}{for each edge~$(u, v)\in E$}\xxx
	\aaD {4}{if~($dist[v] > dist[u] + l(u,v)$)}\xxx
	\aae {$dist[v] = dist[u] + l(u,v)$;}\xxx
	\aae {\textcolor{blue}{$prev[v] = u$;}}\xxx
	\aae {decrease-key~($PQ$, $v$, $dist[v]$);}\xxx
	\aad {end if;}\xxx
	\aac {end for;}\xxx
	\aab {end while;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}

\begin{minipage}{0.8\textwidth}
	\aaA {9}{Algorithm Bellman-Ford~($G = (V, E)$, $l(e)$ for any $e\in E$, $s \in V$)}\xxx
	\aab {init an array $dist$ of size $|V|$;}\xxx
	\aab {$dist[s] = 0$; $dist[v] = \infty$ for any $v\neq s$;}\xxx
	\aab {\textcolor{blue}{$prev[v] = null$, for any $v\in V$};}\xxx
	\aaB {4}{for $k = 1 \to |V| - 1$}\xxx
	\aaC {2}{for each edge $(u,v)\in E$}\xxx
	\aad {$update(u,v)$;}\xxx
	\aac {end for;}\xxx
	\aab {end for;}\xxx
%	\aab {report: $dist[v]$ gives $distance(s,v)$, for any $v\in V$;}\xxx
	\aaa {end algorithm;}\xxx
\end{minipage}

\begin{minipage}{0.8\textwidth}
	\aaA {5}{procedure update~(edge $(u,v)\in E$)}\xxx
	\aaB {3}{if~($dist[v] > dist[u] + l(u,v)$)}\xxx
	\aac {$dist[v] = dist[u] + l(u,v)$;}\xxx
	\aac {\textcolor{blue}{$prev[v]= u$};}\xxx
	\aab {end if;}\xxx
	\aaa {end procedure;}\xxx
\end{minipage}


We now show the corresponding graph $T = (V, \{(pre[v], v)\mid v\in V\})$ is a shortest path tree of $G$.

\begin{fact}
\label{fact2}
At any time of the algorithm, for any $v\in V$, let $u = prev[v]$, if $u\neq null$ then $dist[v] = dist[u] + l(u,v)$;
in particular, when the algorithm terminates, we have $distance(s,v) = distance(s,u) + l(u,v)$.
\end{fact}
The first part of above fact is a direct consequence of each algorithm as we update $prev$ right after updating $dist$.
The secon part also uses the that when each algorithm terminates, we have $dist[v] = distance(s,v)$.

Note although we use $T$ but we haven't showed that $T$ is a tree.  Now we prove it. 
\begin{fact}
$T$ does not contain cycle, if all cycles in $G$ are positive cycles.
\end{fact}
\emph{Proof.} Suppose conversely that there exists a cycle $C = v_1\to v_2\to \cdots \to v_k\to v_1$ in $T$.
Following above fact, we have $dist[v_i] = dist[v_{i-1}] + l(v_{i-1},v_i)$, for every $1 < i \le k$
and $dist[v_1] = dist[v_k] + l(v_k,v_1)$.
Summing up both sides gives $\sum_{e\in C} l(e) = 0$, contradicting to the the assumption
that all cycles have positive length.\qed

\begin{fact}
Graph $T$ is a rooted tree with $s$ being the root.
\end{fact}
\emph{Proof.} This is a direct consequence of the following facts: the in-degree of $s$ is 0; each vertex in $T$, except $s$
has in-degree of 1; $T$ does not contain cycle. \qed

\begin{claim}
$T$ is a shortest path tree, if all cycles in $G$ are positive cycles.

\end{claim}
\emph{Proof.} We verify the 4 conditions in the definition of the shortest path tree.
We just showed that $T$ is a rooted tree with $s$ being the root.
It's clear that vertices of $T$ is $V$ and edges of $T$ are subset of edges of $G$.
Now we prove condition 4. Let $p: s = v_0 \to v_1 \to v_2 \to \cdots \to v_k$ be the path from $s$ to $v_k$ in $T$.
By the construction of $T$, we know that $prev[v_i] = v_{i - 1}$, $1\le i \le k$.
Therefore, using Fact~\ref{fact2}, we have $distance(s, v_i) = distance(s, v_{i-1}) + l(v_{i-1}, v)$.
Hence, the length of this path is exactly $distance(s,v_k)$, i.e., a shortest path from $s$ to $v_k$. \qed



%%Similar to what we did for Dijkstra's algorithm,
%%we can add tracking back pointers, with $prev$ array, to find the shortest path for each vertex.
%%
%%The highlighted ``$>$'' is a key detail. It suggests we give higher priority to $dist(k-1,v)$ when
%%there is a tie between the two cases in the recursion. In other words, whenever possible,
%%the DP algorithm always keeps a path using smaller number of edges. 
%%
%%\begin{fact}
%%If there are multiple shortest paths from $s$ to $v$, the DP algorithm~(using ``$>$'' to break tie)
%%always keeps the one with smallest number of edges.
%%\end{fact}
%%
%%The $prev$ array corresponds to a shortest-path graph, defined as $(V, \{(prev[v], v)\mid v\in V\})$.
%%Is this graph still a shortest-path tree? 
%%The answer is yes. We can try to prove it, using the same approach we used in proving it for Dijkstra's algorithm.
%%But one issue comes out: in the proof for Dijkstra's algorithm, we show that above graph won't have any cycle
%%because it's not possible to have that the length of a cycle is 0~(as Dijkstra's algorithm applies to graphs with positive edge length).
%%However, in the presence of negative edge length, this is possible. See an example in Figure~\ref{fig:cycle1} and Figure~\ref{fig:cycle2}.
%%(Note: if all cycles in $G$ are positive, then the same proof used there can be used here to show that the shortest-path graph is a tree.)
%%
%%Here, the way of breaking tie matters, and is needed in proving a shortest-path tree. With ``$>$'', we always keep the path with smallest number of edges, and hence
%%a cycle of length 0 won't be included in the shortest path. And therefore the shortest-path graph must be a shortest-path tree. 
%%See Figure~\ref{fig:cycle1}. If ``$\ge$'' is used to break tie, then the graph may not be a tree. See Figure~\ref{fig:cycle2}.
%%
%%
%%\begin{minipage}{0.8\textwidth}
%%	\aaA {16}{Algorithm DP-shortest-path~($G = (V, E)$, $l(e)$ for any $e\in E$, $s \in V$)}\xxx
%%	\aab {init a 2D array $dist$ of size $|V|\times |V|$;}\xxx
%%	\aab {$dist[0, s] = 0$; $dist[0, v] = \infty$ for any $v\neq s$;}\xxx
%%	\aab {\textcolor{blue}{$prev[v] = null$, for any $v\in V$};}\xxx
%%	\aaB {10}{for $k = 1 \to |V| - 1$;}\xxx
%%	\aaC {8}{for $v\in V$;}\xxx
%%	\aad {$dist(k,v) = dist(k-1, v)$;}\xxx
%%	\aaD {5}{for each $(u,v)\in E$;}\xxx
%%	\aaE {3}{if~($dist(k,v) \textcolor{red}{~>~} dist(k-1,u) + l(u,v)$)}\xxx
%%	\aaf {$dist(k,v) = dist(k-1,u) + l(u,v)$;}\xxx
%%	\aaf {\textcolor{blue}{$prev[v]= u$};}\xxx
%%	\aae {end if;}\xxx
%%	\aad {end for;}\xxx
%%	\aac {end for;}\xxx
%%	\aab {end for;}\xxx
%%	\aab {$dist[|V|-1,v]$ gives $distance(s,v)$, for any $v\in V$;}\xxx
%%	\aaa {end algorithm;}\xxx
%%\end{minipage}
%%
%%\begin{figure}[h]
%%\centering{\input{cycle1}}
%%\caption{Using ``$>$'' to break tie. In this case the shortest-path graph constructed from $prev$ array is guaranteed to be a shortest path tree.
%%	The $prev$ is next to $dist$ separated with $/$ in each entry.}
%%\label{fig:cycle1}
%%\end{figure}
%%
%%\begin{figure}[t]
%%\centering{\input{cycle2}}
%%\caption{Using ``$\ge$'' to break tie. In this case the shortest-path graph constructed from $prev$ array may not be a shortest path tree.
%%	The $prev$ is next to $dist$ separated with $/$ in each entry.}
%%\label{fig:cycle2}
%%\end{figure}
%%
%%
%%
%%
